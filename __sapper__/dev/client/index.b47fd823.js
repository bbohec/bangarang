import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, v as validate_slots, e as element, t as text, c as claim_element, a as children, b as claim_text, f as detach_dev, g as attr_dev, h as add_location, j as insert_dev, k as append_dev, n as noop, l as space, m as claim_space, w as writable, o as validate_store, p as component_subscribe, q as afterUpdate, r as set_input_value, u as listen_dev, x as binding_callbacks, y as create_component, z as claim_component, A as mount_component, B as transition_in, C as transition_out, D as destroy_component, E as svg_element, F as set_store_value, G as set_data_dev, H as validate_each_argument, I as empty, J as group_outros, K as check_outros, L as destroy_each } from './client.52db5bf3.js';
import { L as Link, l as links } from './Link.927aa771.js';

/* src\components\unit\Buttons\DeclareNewClaimButton.svelte generated by Svelte v3.31.2 */

const file = "src\\components\\unit\\Buttons\\DeclareNewClaimButton.svelte";

function create_fragment(ctx) {
	let button;
	let t;

	const block = {
		c: function create() {
			button = element("button");
			t = text("Declare a new claim");
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { class: true, disabled: true });
			var button_nodes = children(button);
			t = claim_text(button_nodes, "Declare a new claim");
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button, "class", "text-xl mx-5 my-1 px-1 text-bangarang-dark border border-bangarang-darkEmphasis rounded-md bg-bangarang-lightEmphasis");
			button.disabled = true;
			add_location(button, file, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, button, anchor);
			append_dev(button, t);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("DeclareNewClaimButton", slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DeclareNewClaimButton> was created with unknown prop '${key}'`);
	});

	return [];
}

class DeclareNewClaimButton extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "DeclareNewClaimButton",
			options,
			id: create_fragment.name
		});
	}
}

/* src\components\unit\Titles\WelcomeTitle.svelte generated by Svelte v3.31.2 */

const file$1 = "src\\components\\unit\\Titles\\WelcomeTitle.svelte";

function create_fragment$1(ctx) {
	let p;
	let t0;
	let t1;
	let h1;
	let t2;

	const block = {
		c: function create() {
			p = element("p");
			t0 = text("Welcome to");
			t1 = space();
			h1 = element("h1");
			t2 = text("BANGARANG");
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", { class: true });
			var p_nodes = children(p);
			t0 = claim_text(p_nodes, "Welcome to");
			p_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			h1 = claim_element(nodes, "H1", { class: true });
			var h1_nodes = children(h1);
			t2 = claim_text(h1_nodes, "BANGARANG");
			h1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(p, "class", "text-2xl text-bangarang-darkEmphasis my-1");
			add_location(p, file$1, 0, 0, 0);
			attr_dev(h1, "class", "text-4xl text-bangarang-darkEmphasis my-1");
			add_location(h1, file$1, 1, 0, 69);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t0);
			insert_dev(target, t1, anchor);
			insert_dev(target, h1, anchor);
			append_dev(h1, t2);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(h1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("WelcomeTitle", slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<WelcomeTitle> was created with unknown prop '${key}'`);
	});

	return [];
}

class WelcomeTitle extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "WelcomeTitle",
			options,
			id: create_fragment$1.name
		});
	}
}

/* src\components\unit\Descriptions\BangarangDescription.svelte generated by Svelte v3.31.2 */

const file$2 = "src\\components\\unit\\Descriptions\\BangarangDescription.svelte";

function create_fragment$2(ctx) {
	let p;
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text("Bangarang is an open source and free direct democratic claim system. It allows anybody to declare or search for claim and claiming for them anonymously.");
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", { class: true });
			var p_nodes = children(p);
			t = claim_text(p_nodes, "Bangarang is an open source and free direct democratic claim system. It allows anybody to declare or search for claim and claiming for them anonymously.");
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(p, "class", "text-xs text-center text-bangarang-darkEmphasis my-1");
			add_location(p, file$2, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, p, anchor);
			append_dev(p, t);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("BangarangDescription", slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<BangarangDescription> was created with unknown prop '${key}'`);
	});

	return [];
}

class BangarangDescription extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "BangarangDescription",
			options,
			id: create_fragment$2.name
		});
	}
}

const initialClaimSearchValue = '';
const claimSearchStore = writable(initialClaimSearchValue);

/* src\components\unit\SearchBars\ClaimSearchBar.svelte generated by Svelte v3.31.2 */
const file$3 = "src\\components\\unit\\SearchBars\\ClaimSearchBar.svelte";

function create_fragment$3(ctx) {
	let input;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			input = claim_element(nodes, "INPUT", {
				class: true,
				type: true,
				placeholder: true
			});

			this.h();
		},
		h: function hydrate() {
			attr_dev(input, "class", "text-xl text-center mx-5 my-1 text-bangarang-dark placeholder-bangarang-darkEmphasis border-bangarang-lightEmphasis border rounded-md");
			attr_dev(input, "type", "text");
			attr_dev(input, "placeholder", "Find a claim...");
			add_location(input, file$3, 6, 0, 285);
		},
		m: function mount(target, anchor) {
			insert_dev(target, input, anchor);
			set_input_value(input, /*$claimSearchStore*/ ctx[1]);
			/*input_binding*/ ctx[3](input);

			if (!mounted) {
				dispose = listen_dev(input, "input", /*input_input_handler*/ ctx[2]);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*$claimSearchStore*/ 2 && input.value !== /*$claimSearchStore*/ ctx[1]) {
				set_input_value(input, /*$claimSearchStore*/ ctx[1]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(input);
			/*input_binding*/ ctx[3](null);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let $claimSearchStore;
	validate_store(claimSearchStore, "claimSearchStore");
	component_subscribe($$self, claimSearchStore, $$value => $$invalidate(1, $claimSearchStore = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ClaimSearchBar", slots, []);
	let searchBar;

	afterUpdate(() => {
		if ($claimSearchStore.length === 1) searchBar.focus();
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ClaimSearchBar> was created with unknown prop '${key}'`);
	});

	function input_input_handler() {
		$claimSearchStore = this.value;
		claimSearchStore.set($claimSearchStore);
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? "unshift" : "push"](() => {
			searchBar = $$value;
			$$invalidate(0, searchBar);
		});
	}

	$$self.$capture_state = () => ({
		afterUpdate,
		claimSearchStore,
		searchBar,
		$claimSearchStore
	});

	$$self.$inject_state = $$props => {
		if ("searchBar" in $$props) $$invalidate(0, searchBar = $$props.searchBar);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [searchBar, $claimSearchStore, input_input_handler, input_binding];
}

class ClaimSearchBar extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ClaimSearchBar",
			options,
			id: create_fragment$3.name
		});
	}
}

/* src\components\views\MainMenu\WelcomePageView.svelte generated by Svelte v3.31.2 */
const file$4 = "src\\components\\views\\MainMenu\\WelcomePageView.svelte";

function create_fragment$4(ctx) {
	let main;
	let welcometitle;
	let t0;
	let bangarangdescription;
	let t1;
	let footer;
	let claimsearchbar;
	let t2;
	let declarenewclaimbutton;
	let t3;
	let link;
	let current;
	welcometitle = new WelcomeTitle({ $$inline: true });
	bangarangdescription = new BangarangDescription({ $$inline: true });
	claimsearchbar = new ClaimSearchBar({ $$inline: true });
	declarenewclaimbutton = new DeclareNewClaimButton({ $$inline: true });

	link = new Link({
			props: {
				size: "small",
				linkName: "What is Bangarang?",
				linkHref: links.businessModel
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			main = element("main");
			create_component(welcometitle.$$.fragment);
			t0 = space();
			create_component(bangarangdescription.$$.fragment);
			t1 = space();
			footer = element("footer");
			create_component(claimsearchbar.$$.fragment);
			t2 = space();
			create_component(declarenewclaimbutton.$$.fragment);
			t3 = space();
			create_component(link.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			main = claim_element(nodes, "MAIN", { class: true });
			var main_nodes = children(main);
			claim_component(welcometitle.$$.fragment, main_nodes);
			t0 = claim_space(main_nodes);
			claim_component(bangarangdescription.$$.fragment, main_nodes);
			main_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			footer = claim_element(nodes, "FOOTER", { class: true });
			var footer_nodes = children(footer);
			claim_component(claimsearchbar.$$.fragment, footer_nodes);
			t2 = claim_space(footer_nodes);
			claim_component(declarenewclaimbutton.$$.fragment, footer_nodes);
			t3 = claim_space(footer_nodes);
			claim_component(link.$$.fragment, footer_nodes);
			footer_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(main, "class", "flex-grow overflow-y-auto flex flex-col items-center justify-center");
			add_location(main, file$4, 7, 0, 576);
			attr_dev(footer, "class", "flex flex-col mb-1");
			add_location(footer, file$4, 11, 0, 719);
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			mount_component(welcometitle, main, null);
			append_dev(main, t0);
			mount_component(bangarangdescription, main, null);
			insert_dev(target, t1, anchor);
			insert_dev(target, footer, anchor);
			mount_component(claimsearchbar, footer, null);
			append_dev(footer, t2);
			mount_component(declarenewclaimbutton, footer, null);
			append_dev(footer, t3);
			mount_component(link, footer, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(welcometitle.$$.fragment, local);
			transition_in(bangarangdescription.$$.fragment, local);
			transition_in(claimsearchbar.$$.fragment, local);
			transition_in(declarenewclaimbutton.$$.fragment, local);
			transition_in(link.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(welcometitle.$$.fragment, local);
			transition_out(bangarangdescription.$$.fragment, local);
			transition_out(claimsearchbar.$$.fragment, local);
			transition_out(declarenewclaimbutton.$$.fragment, local);
			transition_out(link.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(main);
			destroy_component(welcometitle);
			destroy_component(bangarangdescription);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(footer);
			destroy_component(claimsearchbar);
			destroy_component(declarenewclaimbutton);
			destroy_component(link);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("WelcomePageView", slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<WelcomePageView> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		DeclareNewClaimButton,
		links,
		Link,
		WelcomeTitle,
		BangarangDescription,
		ClaimSearchBar
	});

	return [];
}

class WelcomePageView extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "WelcomePageView",
			options,
			id: create_fragment$4.name
		});
	}
}

/* src\components\unit\Icons\BackIcon.svelte generated by Svelte v3.31.2 */

const file$5 = "src\\components\\unit\\Icons\\BackIcon.svelte";

function create_fragment$5(ctx) {
	let svg;
	let path;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			svg = claim_element(
				nodes,
				"svg",
				{
					class: true,
					xmlns: true,
					fill: true,
					viewBox: true,
					stroke: true
				},
				1
			);

			var svg_nodes = children(svg);

			path = claim_element(
				svg_nodes,
				"path",
				{
					"stroke-linecap": true,
					"stroke-linejoin": true,
					"stroke-width": true,
					d: true
				},
				1
			);

			children(path).forEach(detach_dev);
			svg_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "stroke-linecap", "round");
			attr_dev(path, "stroke-linejoin", "round");
			attr_dev(path, "stroke-width", "2");
			attr_dev(path, "d", "M10 19l-7-7m0 0l7-7m-7 7h18");
			add_location(path, file$5, 1, 4, 164);
			attr_dev(svg, "class", "w-4 h-4 mr-1 stroke-current text-bangarang-darkEmphasis");
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			attr_dev(svg, "fill", "none");
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "stroke", "currentColor");
			add_location(svg, file$5, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("BackIcon", slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<BackIcon> was created with unknown prop '${key}'`);
	});

	return [];
}

class BackIcon extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "BackIcon",
			options,
			id: create_fragment$5.name
		});
	}
}

/* src\components\unit\Links\BackToMainMenuLink.svelte generated by Svelte v3.31.2 */
const file$6 = "src\\components\\unit\\Links\\BackToMainMenuLink.svelte";

function create_fragment$6(ctx) {
	let span;
	let backicon;
	let p;
	let t;
	let current;
	let mounted;
	let dispose;
	backicon = new BackIcon({ $$inline: true });

	const block = {
		c: function create() {
			span = element("span");
			create_component(backicon.$$.fragment);
			p = element("p");
			t = text("Back to main menu.");
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			claim_component(backicon.$$.fragment, span_nodes);
			p = claim_element(span_nodes, "P", { class: true });
			var p_nodes = children(p);
			t = claim_text(p_nodes, "Back to main menu.");
			p_nodes.forEach(detach_dev);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(p, "class", "text-xs text-bangarang-darkEmphasis underline");
			add_location(p, file$6, 4, 49, 304);
			attr_dev(span, "class", "flex items-center px-2");
			add_location(span, file$6, 4, 0, 255);
		},
		m: function mount(target, anchor) {
			insert_dev(target, span, anchor);
			mount_component(backicon, span, null);
			append_dev(span, p);
			append_dev(p, t);
			current = true;

			if (!mounted) {
				dispose = listen_dev(p, "click", /*resetClaimSearch*/ ctx[0], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(backicon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(backicon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			destroy_component(backicon);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	let $claimSearchStore;
	validate_store(claimSearchStore, "claimSearchStore");
	component_subscribe($$self, claimSearchStore, $$value => $$invalidate(1, $claimSearchStore = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("BackToMainMenuLink", slots, []);
	const resetClaimSearch = () => set_store_value(claimSearchStore, $claimSearchStore = "", $claimSearchStore);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<BackToMainMenuLink> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		BackIcon,
		claimSearchStore,
		resetClaimSearch,
		$claimSearchStore
	});

	return [resetClaimSearch];
}

class BackToMainMenuLink extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "BackToMainMenuLink",
			options,
			id: create_fragment$6.name
		});
	}
}

const retreiveClaimsByClaimSearchValue = (claimSearchValue) => {
    return claims.filter(claim => claim.title.includes(claimSearchValue));
};
const claims = new Array();
claims.push({ title: "MonResto only offers meat in its menus, he needs at least one menu with only Vegan ingredients." });
claims.push({ title: "Does MonResto offer too much meat in its menus?" });
claims.push({ title: "PasMonResto does not offer meat." });
claims.push({ title: "What are the conditions of validity of an article of the constitution of the Awesome App team?" });
claims.push({ title: "Thundercats are on the move, Thundercats are loose. Feel the magic, hear the roar, Thundercats are loose. Thunder, thunder, thunder, Thundercats! Thunder, thunder, thunder, Thundercats! Thunder, thunder, thunder, Thundercats! Thunder, thunder, thunder, Thundercats! Thundercats! " });
claims.push({ title: "Top Cat! The most effectual Top Cat! Who’s intellectual close friends get to call him T.C., providing it’s with dignity. Top Cat! The indisputable leader of the gang. He’s the boss, he’s a pip, he’s the championship. He’s the most tip top, Top Cat. " });
claims.push({ title: "PasMonResto does not offer meat." });
claims.push({ title: "PasMonResto does not offer meat." });
claims.push({ title: "PasMonResto does not offer meat." });
claims.push({ title: "PasMonResto does not offer meat." });
claims.push({ title: "PasMonResto does not offer meat." });
claims.push({ title: "PasMonResto does not offer meat." });
claims.push({ title: "PasMonResto does not offer meat." });
claims.push({ title: "PasMonResto does not offer meat." });
claims.push({ title: "PasMonResto does not offer meat." });
claims.push({ title: "PasMonResto does not offer meat." });
claims.push({ title: "PasMonResto does not offer meat." });

/* src\components\unit\Icons\ChevronRight.svelte generated by Svelte v3.31.2 */

const file$7 = "src\\components\\unit\\Icons\\ChevronRight.svelte";

function create_fragment$7(ctx) {
	let svg;
	let path;

	const block = {
		c: function create() {
			svg = svg_element("svg");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			svg = claim_element(
				nodes,
				"svg",
				{
					class: true,
					fill: true,
					stroke: true,
					viewBox: true,
					xmlns: true
				},
				1
			);

			var svg_nodes = children(svg);

			path = claim_element(
				svg_nodes,
				"path",
				{
					"stroke-linecap": true,
					"stroke-linejoin": true,
					"stroke-width": true,
					d: true
				},
				1
			);

			children(path).forEach(detach_dev);
			svg_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "stroke-linecap", "round");
			attr_dev(path, "stroke-linejoin", "round");
			attr_dev(path, "stroke-width", "2");
			attr_dev(path, "d", "M9 5l7 7-7 7");
			add_location(path, file$7, 1, 4, 125);
			attr_dev(svg, "class", "w-1/2 h-1/2 mx-1");
			attr_dev(svg, "fill", "none");
			attr_dev(svg, "stroke", "currentColor");
			attr_dev(svg, "viewBox", "0 0 24 24");
			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
			add_location(svg, file$7, 0, 0, 0);
		},
		m: function mount(target, anchor) {
			insert_dev(target, svg, anchor);
			append_dev(svg, path);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$7($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ChevronRight", slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ChevronRight> was created with unknown prop '${key}'`);
	});

	return [];
}

class ChevronRight extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$7, create_fragment$7, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ChevronRight",
			options,
			id: create_fragment$7.name
		});
	}
}

/* src\components\unit\Cards\SearchedClaim.svelte generated by Svelte v3.31.2 */
const file$8 = "src\\components\\unit\\Cards\\SearchedClaim.svelte";

function create_fragment$8(ctx) {
	let div;
	let p;
	let t;
	let chevronright;
	let current;
	chevronright = new ChevronRight({ $$inline: true });

	const block = {
		c: function create() {
			div = element("div");
			p = element("p");
			t = text(/*title*/ ctx[0]);
			create_component(chevronright.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			p = claim_element(div_nodes, "P", { class: true });
			var p_nodes = children(p);
			t = claim_text(p_nodes, /*title*/ ctx[0]);
			p_nodes.forEach(detach_dev);
			claim_component(chevronright.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(p, "class", " text-bangarang-dark flex-grow");
			add_location(p, file$8, 4, 4, 246);
			attr_dev(div, "class", "border rounded my-1 p-1 border-bangarang-lightEmphasis flex items-center");
			add_location(div, file$8, 3, 0, 154);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, p);
			append_dev(p, t);
			mount_component(chevronright, div, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (!current || dirty & /*title*/ 1) set_data_dev(t, /*title*/ ctx[0]);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(chevronright.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(chevronright.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(chevronright);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$8.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$8($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("SearchedClaim", slots, []);
	let { title } = $$props;
	const writable_props = ["title"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SearchedClaim> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("title" in $$props) $$invalidate(0, title = $$props.title);
	};

	$$self.$capture_state = () => ({ ChevronRight, title });

	$$self.$inject_state = $$props => {
		if ("title" in $$props) $$invalidate(0, title = $$props.title);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [title];
}

class SearchedClaim extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$8, create_fragment$8, safe_not_equal, { title: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "SearchedClaim",
			options,
			id: create_fragment$8.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*title*/ ctx[0] === undefined && !("title" in props)) {
			console.warn("<SearchedClaim> was created without expected prop 'title'");
		}
	}

	get title() {
		throw new Error("<SearchedClaim>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<SearchedClaim>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src\components\unit\Lists\SearchedClaims.svelte generated by Svelte v3.31.2 */

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[1] = list[i];
	return child_ctx;
}

// (8:0) {#each searchedClaims as searchedClaim}
function create_each_block(ctx) {
	let searchedclaim;
	let current;

	searchedclaim = new SearchedClaim({
			props: { title: /*searchedClaim*/ ctx[1].title },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(searchedclaim.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(searchedclaim.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(searchedclaim, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const searchedclaim_changes = {};
			if (dirty & /*searchedClaims*/ 1) searchedclaim_changes.title = /*searchedClaim*/ ctx[1].title;
			searchedclaim.$set(searchedclaim_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(searchedclaim.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(searchedclaim.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(searchedclaim, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(8:0) {#each searchedClaims as searchedClaim}",
		ctx
	});

	return block;
}

function create_fragment$9(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*searchedClaims*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*searchedClaims*/ 1) {
				each_value = /*searchedClaims*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$9.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$9($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("SearchedClaims", slots, []);
	
	let searchedClaims = new Array();

	claimSearchStore.subscribe(claimSearchValue => {
		$$invalidate(0, searchedClaims = retreiveClaimsByClaimSearchValue(claimSearchValue));
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SearchedClaims> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		retreiveClaimsByClaimSearchValue,
		claimSearchStore,
		SearchedClaim,
		searchedClaims
	});

	$$self.$inject_state = $$props => {
		if ("searchedClaims" in $$props) $$invalidate(0, searchedClaims = $$props.searchedClaims);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [searchedClaims];
}

class SearchedClaims extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$9, create_fragment$9, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "SearchedClaims",
			options,
			id: create_fragment$9.name
		});
	}
}

/* src\components\views\MainMenu\ClaimSearchView.svelte generated by Svelte v3.31.2 */
const file$9 = "src\\components\\views\\MainMenu\\ClaimSearchView.svelte";

function create_fragment$a(ctx) {
	let main;
	let searchedclaims;
	let t0;
	let footer;
	let claimsearchbar;
	let t1;
	let backtomainmenulink;
	let current;
	searchedclaims = new SearchedClaims({ $$inline: true });
	claimsearchbar = new ClaimSearchBar({ $$inline: true });
	backtomainmenulink = new BackToMainMenuLink({ $$inline: true });

	const block = {
		c: function create() {
			main = element("main");
			create_component(searchedclaims.$$.fragment);
			t0 = space();
			footer = element("footer");
			create_component(claimsearchbar.$$.fragment);
			t1 = space();
			create_component(backtomainmenulink.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			main = claim_element(nodes, "MAIN", { class: true });
			var main_nodes = children(main);
			claim_component(searchedclaims.$$.fragment, main_nodes);
			main_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			footer = claim_element(nodes, "FOOTER", { class: true });
			var footer_nodes = children(footer);
			claim_component(claimsearchbar.$$.fragment, footer_nodes);
			t1 = claim_space(footer_nodes);
			claim_component(backtomainmenulink.$$.fragment, footer_nodes);
			footer_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(main, "class", "flex-grow overflow-y-auto");
			add_location(main, file$9, 4, 0, 330);
			attr_dev(footer, "class", "flex flex-col mb-1");
			add_location(footer, file$9, 7, 0, 404);
		},
		m: function mount(target, anchor) {
			insert_dev(target, main, anchor);
			mount_component(searchedclaims, main, null);
			insert_dev(target, t0, anchor);
			insert_dev(target, footer, anchor);
			mount_component(claimsearchbar, footer, null);
			append_dev(footer, t1);
			mount_component(backtomainmenulink, footer, null);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(searchedclaims.$$.fragment, local);
			transition_in(claimsearchbar.$$.fragment, local);
			transition_in(backtomainmenulink.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(searchedclaims.$$.fragment, local);
			transition_out(claimsearchbar.$$.fragment, local);
			transition_out(backtomainmenulink.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(main);
			destroy_component(searchedclaims);
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(footer);
			destroy_component(claimsearchbar);
			destroy_component(backtomainmenulink);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$a($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("ClaimSearchView", slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ClaimSearchView> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		ClaimSearchBar,
		BackToMainMenuLink,
		SearchedClaims
	});

	return [];
}

class ClaimSearchView extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$a, create_fragment$a, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ClaimSearchView",
			options,
			id: create_fragment$a.name
		});
	}
}

/* src\routes\index.svelte generated by Svelte v3.31.2 */

// (10:0) {:else}
function create_else_block(ctx) {
	let claimsearchview;
	let current;
	claimsearchview = new ClaimSearchView({ $$inline: true });

	const block = {
		c: function create() {
			create_component(claimsearchview.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(claimsearchview.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(claimsearchview, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(claimsearchview.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(claimsearchview.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(claimsearchview, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(10:0) {:else}",
		ctx
	});

	return block;
}

// (8:0) {#if $claimSearchStore === ''}
function create_if_block(ctx) {
	let welcomepageview;
	let current;
	welcomepageview = new WelcomePageView({ $$inline: true });

	const block = {
		c: function create() {
			create_component(welcomepageview.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(welcomepageview.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(welcomepageview, target, anchor);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(welcomepageview.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(welcomepageview.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(welcomepageview, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(8:0) {#if $claimSearchStore === ''}",
		ctx
	});

	return block;
}

function create_fragment$b(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*$claimSearchStore*/ ctx[0] === "") return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index !== previous_block_index) {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$b.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$b($$self, $$props, $$invalidate) {
	let $claimSearchStore;
	validate_store(claimSearchStore, "claimSearchStore");
	component_subscribe($$self, claimSearchStore, $$value => $$invalidate(0, $claimSearchStore = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Routes", slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Routes> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({
		WelcomePageView,
		ClaimSearchView,
		claimSearchStore,
		$claimSearchStore
	});

	return [$claimSearchStore];
}

class Routes extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$b, create_fragment$b, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Routes",
			options,
			id: create_fragment$b.name
		});
	}
}

export default Routes;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguYjQ3ZmQ4MjMuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3N0b3Jlcy9jbGFpbVNlYXJjaFN0b3JlLnRzIiwiLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvdW5pdC9TZWFyY2hCYXJzL0NsYWltU2VhcmNoQmFyLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3ZpZXdzL01haW5NZW51L1dlbGNvbWVQYWdlVmlldy5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy91bml0L0xpbmtzL0JhY2tUb01haW5NZW51TGluay5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy9sb2dpYy9yZXRyZWl2ZUNsYWltc0J5Q2xhaW1TZWFyY2hWYWx1ZS50cyIsIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3VuaXQvQ2FyZHMvU2VhcmNoZWRDbGFpbS5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvY29tcG9uZW50cy91bml0L0xpc3RzL1NlYXJjaGVkQ2xhaW1zLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvaW5kZXguc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbbnVsbCwiPHNjcmlwdCBsYW5nPVwidHNcIj5cclxuICAgIGltcG9ydCB7IGFmdGVyVXBkYXRlIH0gZnJvbSBcInN2ZWx0ZVwiO1xyXG4gICAgaW1wb3J0IHtjbGFpbVNlYXJjaFN0b3JlfSBmcm9tIFwiLi4vLi4vc3RvcmVzL2NsYWltU2VhcmNoU3RvcmVcIlxyXG4gICAgbGV0IHNlYXJjaEJhcjp7Zm9jdXMoKTp2b2lkfTtcclxuICAgIGFmdGVyVXBkYXRlKCgpPT4ge2lmICgkY2xhaW1TZWFyY2hTdG9yZS5sZW5ndGggPT09IDEpIHNlYXJjaEJhci5mb2N1cygpfSlcclxuPC9zY3JpcHQ+XHJcbjxpbnB1dCBcclxuICAgIGNsYXNzPVwidGV4dC14bCB0ZXh0LWNlbnRlciBteC01IG15LTEgdGV4dC1iYW5nYXJhbmctZGFyayBwbGFjZWhvbGRlci1iYW5nYXJhbmctZGFya0VtcGhhc2lzIGJvcmRlci1iYW5nYXJhbmctbGlnaHRFbXBoYXNpcyBib3JkZXIgcm91bmRlZC1tZFwiIFxyXG4gICAgdHlwZT1cInRleHRcIiBcclxuICAgIHBsYWNlaG9sZGVyPVwiRmluZCBhIGNsYWltLi4uXCIgXHJcbiAgICBiaW5kOnZhbHVlPXskY2xhaW1TZWFyY2hTdG9yZX0gXHJcbiAgICBiaW5kOnRoaXM9e3NlYXJjaEJhcn1cclxuPiIsIjxzY3JpcHQgbGFuZz1cInRzXCI+XHJcbiAgICBpbXBvcnQgRGVjbGFyZU5ld0NsYWltQnV0dG9uIGZyb20gJy4uLy4uLy4uL2NvbXBvbmVudHMvdW5pdC9CdXR0b25zL0RlY2xhcmVOZXdDbGFpbUJ1dHRvbi5zdmVsdGUnXHJcbiAgICBpbXBvcnQge2xpbmtzfSBmcm9tIFwiLi4vLi4vLi4vY29tcG9uZW50cy9yb3V0aW5nL2xpbmtzXCJcclxuICAgIGltcG9ydCBMaW5rIGZyb20gJy4uLy4uLy4uL2NvbXBvbmVudHMvdW5pdC9MaW5rcy9MaW5rLnN2ZWx0ZSdcclxuICAgIGltcG9ydCBXZWxjb21lVGl0bGUgZnJvbSAnLi4vLi4vLi4vY29tcG9uZW50cy91bml0L1RpdGxlcy9XZWxjb21lVGl0bGUuc3ZlbHRlJ1xyXG4gICAgaW1wb3J0IEJhbmdhcmFuZ0Rlc2NyaXB0aW9uIGZyb20gJy4uLy4uLy4uL2NvbXBvbmVudHMvdW5pdC9EZXNjcmlwdGlvbnMvQmFuZ2FyYW5nRGVzY3JpcHRpb24uc3ZlbHRlJ1xyXG4gICAgaW1wb3J0IENsYWltU2VhcmNoQmFyIGZyb20gJy4uLy4uLy4uL2NvbXBvbmVudHMvdW5pdC9TZWFyY2hCYXJzL0NsYWltU2VhcmNoQmFyLnN2ZWx0ZSdcclxuPC9zY3JpcHQ+XHJcbjxtYWluIGNsYXNzPVwiZmxleC1ncm93IG92ZXJmbG93LXktYXV0byBmbGV4IGZsZXgtY29sIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlclwiPlxyXG4gICAgPFdlbGNvbWVUaXRsZS8+XHJcbiAgICA8QmFuZ2FyYW5nRGVzY3JpcHRpb24vPlxyXG48L21haW4+XHJcbjxmb290ZXIgY2xhc3M9XCJmbGV4IGZsZXgtY29sIG1iLTFcIj5cclxuICAgIDxDbGFpbVNlYXJjaEJhci8+XHJcbiAgICA8RGVjbGFyZU5ld0NsYWltQnV0dG9uLz5cclxuICAgIDxMaW5rIHNpemU9XCJzbWFsbFwiIGxpbmtOYW1lPVwiV2hhdCBpcyBCYW5nYXJhbmc/XCIgbGlua0hyZWY9e2xpbmtzLmJ1c2luZXNzTW9kZWx9Lz5cclxuPC9mb290ZXI+IiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cclxuICAgIGltcG9ydCBCYWNrSWNvbiBmcm9tICcuLi9JY29ucy9CYWNrSWNvbi5zdmVsdGUnXHJcbiAgICBpbXBvcnQge2NsYWltU2VhcmNoU3RvcmV9IGZyb20gJy4uLy4uL3N0b3Jlcy9jbGFpbVNlYXJjaFN0b3JlJ1xyXG4gICAgY29uc3QgcmVzZXRDbGFpbVNlYXJjaCA9ICgpID0+ICRjbGFpbVNlYXJjaFN0b3JlID0gJyc7XHJcbjwvc2NyaXB0PlxyXG48c3BhbiBjbGFzcz1cImZsZXggaXRlbXMtY2VudGVyIHB4LTJcIiA+PEJhY2tJY29uLz48cCBjbGFzcz1cInRleHQteHMgdGV4dC1iYW5nYXJhbmctZGFya0VtcGhhc2lzIHVuZGVybGluZVwiIG9uOmNsaWNrPXtyZXNldENsYWltU2VhcmNofT5CYWNrIHRvIG1haW4gbWVudS48L3A+PC9zcGFuPiIsbnVsbCwiPHNjcmlwdCBsYW5nPVwidHNcIj5cclxuICAgIGltcG9ydCBDaGV2cm9uUmlnaHQgZnJvbSAnLi4vSWNvbnMvQ2hldnJvblJpZ2h0LnN2ZWx0ZSdcclxuICAgIGV4cG9ydCBsZXQgdGl0bGU6c3RyaW5nXHJcbjwvc2NyaXB0PlxyXG48ZGl2IGNsYXNzPVwiYm9yZGVyIHJvdW5kZWQgbXktMSBwLTEgYm9yZGVyLWJhbmdhcmFuZy1saWdodEVtcGhhc2lzIGZsZXggaXRlbXMtY2VudGVyXCI+XHJcbiAgICA8cCBjbGFzcz1cIiB0ZXh0LWJhbmdhcmFuZy1kYXJrIGZsZXgtZ3Jvd1wiPnt0aXRsZX08L3A+PENoZXZyb25SaWdodC8+XHJcbjwvZGl2PlxyXG4iLCI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxyXG4gICAgaW1wb3J0IHR5cGUgeyBDbGFpbUNvbnRyYWN0IH0gZnJvbSAnLi4vLi4vaW50ZXJmYWNlcy9DbGFpbUNvbnRyYWN0JztcclxuICAgIGltcG9ydCB7IHJldHJlaXZlQ2xhaW1zQnlDbGFpbVNlYXJjaFZhbHVlIH0gZnJvbSAnLi4vLi4vbG9naWMvcmV0cmVpdmVDbGFpbXNCeUNsYWltU2VhcmNoVmFsdWUnO1xyXG4gICAgaW1wb3J0IHtjbGFpbVNlYXJjaFN0b3JlfSBmcm9tICcuLi8uLi9zdG9yZXMvY2xhaW1TZWFyY2hTdG9yZSdcclxuICAgIGltcG9ydCBTZWFyY2hlZENsYWltIGZyb20gJy4uLy4uLy4uL2NvbXBvbmVudHMvdW5pdC9DYXJkcy9TZWFyY2hlZENsYWltLnN2ZWx0ZSdcclxuICAgIGxldCBzZWFyY2hlZENsYWltcyA9IG5ldyBBcnJheTxDbGFpbUNvbnRyYWN0PigpXHJcbiAgICBjbGFpbVNlYXJjaFN0b3JlLnN1YnNjcmliZShjbGFpbVNlYXJjaFZhbHVlID0+e3NlYXJjaGVkQ2xhaW1zPSByZXRyZWl2ZUNsYWltc0J5Q2xhaW1TZWFyY2hWYWx1ZShjbGFpbVNlYXJjaFZhbHVlKX0pIFxyXG48L3NjcmlwdD5cclxueyNlYWNoIHNlYXJjaGVkQ2xhaW1zIGFzIHNlYXJjaGVkQ2xhaW19XHJcbiAgICA8U2VhcmNoZWRDbGFpbSB0aXRsZT17c2VhcmNoZWRDbGFpbS50aXRsZX0vPlxyXG57L2VhY2h9IiwiPHNjcmlwdCBsYW5nPVwidHNcIj5cblx0aW1wb3J0IFdlbGNvbWVQYWdlVmlldyBmcm9tICcuLi9jb21wb25lbnRzL3ZpZXdzL01haW5NZW51L1dlbGNvbWVQYWdlVmlldy5zdmVsdGUnXG5cdGltcG9ydCBDbGFpbVNlYXJjaFZpZXcgZnJvbSAnLi4vY29tcG9uZW50cy92aWV3cy9NYWluTWVudS9DbGFpbVNlYXJjaFZpZXcuc3ZlbHRlJ1xuXHRpbXBvcnQge2NsYWltU2VhcmNoU3RvcmV9IGZyb20gXCIuLi9jb21wb25lbnRzL3N0b3Jlcy9jbGFpbVNlYXJjaFN0b3JlXCJcbjwvc2NyaXB0PlxuPHN0eWxlPlxuPC9zdHlsZT5cbnsjaWYgJGNsYWltU2VhcmNoU3RvcmUgPT09ICcnfVxuXHQ8V2VsY29tZVBhZ2VWaWV3Lz5cbns6ZWxzZX1cblx0PENsYWltU2VhcmNoVmlldy8+XG57L2lmfSAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBLE1BQU0sdUJBQXVCLEdBQVUsRUFBRSxDQUFBO0FBQ2xDLE1BQU0sZ0JBQWdCLEdBQUcsUUFBUSxDQUFDLHVCQUF1QixDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnRENRakQsR0FBaUI7Ozs7Ozs7OztnRkFBakIsR0FBaUI7aURBQWpCLEdBQWlCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FQekIsU0FBd0I7O0NBQzVCLFdBQVc7TUFBVyxpQkFBaUIsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFLFNBQVMsQ0FBQyxLQUFLOzs7Ozs7Ozs7O0VBTXpELGlCQUFpQjs7Ozs7O0dBQ2xCLFNBQVM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2NDSXVDLEtBQUssQ0FBQyxhQUFhOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MERDVmtDLEdBQWdCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FGMUgsZ0JBQWdCLDJDQUFTLGlCQUFpQixHQUFHLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNGbEQsTUFBTSxnQ0FBZ0MsR0FBRyxDQUFDLGdCQUF1QjtJQUNwRSxPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQUMsS0FBSyxJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQTtBQUN6RSxDQUFDLENBQUE7QUFDRCxNQUFNLE1BQU0sR0FBRyxJQUFJLEtBQUssRUFBaUIsQ0FBQTtBQUN6QyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUMsS0FBSyxFQUFDLGlHQUFpRyxFQUFDLENBQUMsQ0FBQTtBQUN0SCxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUMsS0FBSyxFQUFDLGlEQUFpRCxFQUFDLENBQUMsQ0FBQTtBQUN0RSxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUMsS0FBSyxFQUFDLGtDQUFrQyxFQUFDLENBQUMsQ0FBQTtBQUN2RCxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUMsS0FBSyxFQUFDLGdHQUFnRyxFQUFDLENBQUMsQ0FBQTtBQUNySCxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUMsS0FBSyxFQUFDLHlSQUF5UixFQUFDLENBQUMsQ0FBQTtBQUM5UyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUMsS0FBSyxFQUFDLDJQQUEyUCxFQUFDLENBQUMsQ0FBQTtBQUNoUixNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUMsS0FBSyxFQUFDLGtDQUFrQyxFQUFDLENBQUMsQ0FBQTtBQUN2RCxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUMsS0FBSyxFQUFDLGtDQUFrQyxFQUFDLENBQUMsQ0FBQTtBQUN2RCxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUMsS0FBSyxFQUFDLGtDQUFrQyxFQUFDLENBQUMsQ0FBQTtBQUN2RCxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUMsS0FBSyxFQUFDLGtDQUFrQyxFQUFDLENBQUMsQ0FBQTtBQUN2RCxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUMsS0FBSyxFQUFDLGtDQUFrQyxFQUFDLENBQUMsQ0FBQTtBQUN2RCxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUMsS0FBSyxFQUFDLGtDQUFrQyxFQUFDLENBQUMsQ0FBQTtBQUN2RCxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUMsS0FBSyxFQUFDLGtDQUFrQyxFQUFDLENBQUMsQ0FBQTtBQUN2RCxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUMsS0FBSyxFQUFDLGtDQUFrQyxFQUFDLENBQUMsQ0FBQTtBQUN2RCxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUMsS0FBSyxFQUFDLGtDQUFrQyxFQUFDLENBQUMsQ0FBQTtBQUN2RCxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUMsS0FBSyxFQUFDLGtDQUFrQyxFQUFDLENBQUMsQ0FBQTtBQUN2RCxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUMsS0FBSyxFQUFDLGtDQUFrQyxFQUFDLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3NCQ2hCUixHQUFLOzs7Ozs7Ozs7cUNBQUwsR0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0VBQUwsR0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztPQUhyQyxLQUFZOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3FDQ09ELEdBQWEsSUFBQyxLQUFLOzs7Ozs7Ozs7Ozs7Ozs7OztxRkFBbkIsR0FBYSxJQUFDLEtBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7cUNBRHRDLEdBQWM7Ozs7Z0NBQW5CLE1BQUk7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQ0FBQyxHQUFjOzs7OytCQUFuQixNQUFJOzs7Ozs7Ozs7Ozs7Ozs7O3dCQUFKLE1BQUk7Ozs7Ozs7Ozs7a0NBQUosTUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBSEUsY0FBYyxPQUFPLEtBQUs7O0NBQzlCLGdCQUFnQixDQUFDLFNBQVMsQ0FBQyxnQkFBZ0I7a0JBQUksY0FBYyxHQUFFLGdDQUFnQyxDQUFDLGdCQUFnQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NEJDQy9HLEdBQWlCLFFBQUssRUFBRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OyJ9
